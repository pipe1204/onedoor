/*
    This program is distributed under the terms of the MIT license.
    Please see the LICENSE file for details.

    Copyright 2020, JC Brand
*/

import './websocket.js';
import { $build, Strophe } from './core.js';

const lmap = {};
lmap['debug'] = Strophe.LogLevel.DEBUG;
lmap['info'] = Strophe.LogLevel.INFO;
lmap['warn'] = Strophe.LogLevel.WARN;
lmap['error'] = Strophe.LogLevel.ERROR;
lmap['fatal'] = Strophe.LogLevel.FATAL;


const parser = new DOMParser();

/** Class: Strophe.WorkerWebsocket
 *  _Private_ helper class that handles a websocket connection inside a shared worker.
 */
Strophe.WorkerWebsocket = class WorkerWebsocket extends Strophe.WebSocket {

    /** PrivateConstructor: Strophe.WorkerWebsocket
     *  Create and initialize a Strophe.WorkerWebsocket object.
     *
     *  Parameters:
     *    (Strophe.Connection) connection - The Strophe.Connection
     *
     *  Returns:
     *    A new Strophe.WorkerWebsocket object.
     */
    constructor (connection) {
        super(connection);
        this._messageHandler = (m) => this._onInitialMessage(m);
        this._conn = connection;
        this.worker = new SharedWorker('./worker.js', 'Strophe XMPP Connection');
        this.worker.onerror = (e) => Strophe.Log(
            Strophe.LogLevel.ERROR,
            `Shared Worker Error: ${e}`
        );
    }

    /** PrivateFunction: _connect
     *  _Private_ function called by Strophe.Connection.connect
     */
    _connect (wait) {
        this.worker.port.start();
        this.worker.port.onmessage = (ev) => this._onWorkerMessage(ev);
        this.worker.port.postMessage(['initConnection', this._conn.service]);

        const data = {
            'jid': this.jid,
            'password': this.pass,
            wait
        }
        this.worker.port.postMessage(['connect', data]);
    }

    _disconnect (readyState, pres) {
        pres && this._conn.send(pres);
        const close = $build("close", { "xmlns": Strophe.NS.FRAMING });
        this._conn.xmlOutput(close.tree());
        const closeString = Strophe.serialize(close);
        this._conn.rawOutput(closeString);
        this.worker.port.postMessage(['send', closeString]);
        this._conn._doDisconnect();
    }

    _onOpen () {
        Strophe.debug("Websocket open");
        const start = this._buildStream();
        this._conn.xmlOutput(start.tree());

        const startString = Strophe.serialize(start);
        this._conn.rawOutput(startString);

        this.worker.port.postMessage(['send', startString]);
    }

    _onClose (e) {
        if (this._conn.connected && !this._conn.disconnecting) {
            Strophe.error("Websocket closed unexpectedly");
            this._conn._doDisconnect();
        } else if (e && e.code === 1006 && !this._conn.connected) {
            // in case the onError callback was not called (Safari 10 does not
            // call onerror when the initial connection fails) we need to
            // dispatch a CONNFAIL status update to be consistent with the
            // behavior on other browsers.
            Strophe.error("Websocket closed unexcectedly");
            this._conn._changeConnectStatus(
                Strophe.Status.CONNFAIL,
                "The WebSocket connection could not be established or was disconnected."
            );
            this._conn._doDisconnect();
        } else {
            Strophe.debug("Websocket closed");
        }
    }

    /** PrivateFunction: _replaceMessageHandler
     * 
     * Called by _onInitialMessage in order to replace itself with the general message handler.
     * This method is overridden by Strophe.WorkerWebsocket, which manages a
     * websocket connection via a service worker and doesn't have direct access
     * to the socket.
     */
    _replaceMessageHandler () {
        this._messageHandler = (m) => this._onMessage(m);
    }

    /** PrivateFunction: _onWorkerMessage
     * _Private_ function that handles messages received from the service worker
     */
    _onWorkerMessage (ev) {
        const { data } = ev;
        const method_name = data[0];
        if (method_name === '_onMessage') {
            this._messageHandler(data[1]);
        } else if (method_name in this._conn) {
            try {
                this._conn[method_name].apply(this._conn, ev.data.slice(1));
            } catch (e) {
                Strophe.log(Strophe.LogLevel.ERROR, e);
            }
        } else if (method_name === 'log') {
            const level = data[1];
            const msg = data[2]
            Strophe.log(lmap[level], msg);
        } else {
            Strophe.log(
                Strophe.LogLevel.ERROR,
                `Found unhandled service worker message: ${data}`
            );
        }
    }
}
