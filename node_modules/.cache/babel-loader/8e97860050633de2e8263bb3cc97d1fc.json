{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useCallback, useRef, useState } from 'react';\nimport config from '../QBconfig';\nimport QB from 'quickblox/quickblox.min';\nimport QBconfig from \"../QBconfig\";\nconst CONFIG = {\n  debug: true,\n  webrtc: {\n    answerTimeInterval: 45,\n    dialingTimeInterval: 5,\n    autoReject: true,\n    incomingLimit: 1\n  }\n};\n\nconst useQuickBlox = () => {\n  _s();\n\n  const loading = useRef(false);\n  const [mySession, setMySession] = useState();\n  const [callStatus, setCallStatus] = useState();\n  const [receivingCall, setReceivingCall] = useState(false);\n  const [noAnswer, setNoAnswer] = useState(false);\n  const [currentUser, setCurrentUser] = useState(false);\n  const initQuickBlox = useCallback(async () => {\n    loading.current = true;\n    const response = await QB.init(config.appId, config.authKey, config.authSecret, config.accountKey, CONFIG);\n    console.log(response);\n    loading.current = false;\n  }, [loading]);\n  const createUserSession = useCallback(async (email, fullName, branch, externalId) => {\n    loading.current = true;\n    let params = {\n      login: email,\n      password: \"OneDoorCompany\",\n      full_name: fullName,\n      tag_list: branch || null,\n      externalId: externalId\n    };\n    const user = await new Promise(function (resolve, reject) {\n      QB.createSession(function (csErr, csRes) {\n        if (csErr) {\n          reject(csErr);\n        } else {\n          /** In first trying to login */\n          QB.login(params, function (loginErr, loginUser) {\n            if (loginErr) {\n              /** Login failed, trying to create account */\n              QB.users.create({\n                'login': params.login,\n                'password': params.password,\n                'full_name': params.full_name,\n                'email': params.login // 'custom_data': params.tag_list\n\n              }, function (createErr, createUser) {\n                if (createErr) {\n                  console.log('[create user] Error:', createErr);\n                  reject(createErr);\n                } else {\n                  QB.login(params, function (reloginErr, reloginUser) {\n                    if (reloginErr) {\n                      console.log('[relogin user] Error:', reloginErr);\n                    } else {\n                      resolve(reloginUser);\n                    }\n                  });\n                }\n              });\n            } else {\n              /** Update info */\n              if (loginUser.full_name !== params.full_name) {\n                QB.users.update(loginUser.id, {\n                  'full_name': params.full_name // 'custom_data': params.tag_list\n\n                }, function (updateError, updateUser) {\n                  if (updateError) {\n                    console.log('APP [update user] Error:', updateError);\n                    reject(updateError);\n                  } else {\n                    resolve(updateUser);\n                  }\n                });\n              } else {\n                resolve(loginUser);\n              }\n            }\n          });\n        }\n      });\n    });\n    loading.current = false;\n    setCurrentUser(user);\n    return user;\n  }, [loading]);\n  const getRepresentativesUsers = useCallback(async users => {\n    loading.current = true;\n    let representatives = [];\n    representatives = await Promise.all(users.map(async user => {\n      let searchParams = {\n        email: user.email\n      };\n      debugger;\n      return new Promise(function (resolve, reject) {\n        QB.users.get(searchParams, function (error, result) {\n          debugger;\n\n          if (result) {\n            resolve(result);\n          }\n        });\n      });\n    }));\n    loading.current = false;\n    return representatives;\n  }, [loading]);\n  const connectChatServer = useCallback(async user => {\n    loading.current = true;\n    let userCredentials = {\n      jid: QB.chat.helpers.getUserJid(user === null || user === void 0 ? void 0 : user.id, QBconfig.appId),\n      password: \"OneDoorCompany\"\n    };\n    QB.chat.connect(userCredentials, function (error, contactList) {\n      if (error) {\n        console.log('ERROR:::', error);\n      } else {\n        localStorage.setItem('isAuth', true);\n      }\n    });\n    loading.current = false;\n  }, [loading]);\n  const makeVideoCall = useCallback(async (representativesFromQB, callType) => {\n    loading.current = true;\n    let calleesIds = [representativesFromQB.id]; // Users' ids, for testing purposes we use just one [0]\n    // let calleesIds = [129779412]; // Users' ids, for testing purposes we use just one [0]\n\n    let sessionType;\n    let mediaParams;\n\n    if (callType === 'VIDEO') {\n      sessionType = QB.webrtc.CallType.VIDEO;\n      mediaParams = {\n        audio: true,\n        video: true,\n        options: {\n          muted: true,\n          mirror: true\n        },\n        elemId: \"localVideo\"\n      };\n    } else {\n      sessionType = QB.webrtc.CallType.AUDIO;\n      mediaParams = {\n        audio: true,\n        video: false,\n        options: {\n          muted: true,\n          mirror: true\n        },\n        elemId: \"localVideo\"\n      };\n    }\n\n    let additionalOptions = {};\n    let session = QB.webrtc.createNewSession(calleesIds, sessionType, null, additionalOptions);\n    setMySession(session);\n    session.getUserMedia(mediaParams, function (error, stream) {\n      if (error) {\n        console.log(error);\n      } else {\n        //run call function here\n        let extension = {\n          \"name\": currentUser.full_name,\n          \"email\": currentUser.email\n        };\n        session.call(extension, function (error) {\n          sendPush(calleesIds);\n          calleesIds.forEach(async function (userID, i, arr) {\n            let peerState = session.connectionStateForUser(userID);\n            console.log('peerState', peerState);\n\n            if (peerState === QB.webrtc.PeerConnectionState.CLOSED) {\n              console.log('======= CONNECTION CLOSED'); // Turn off\n              //app.helpers.toggleRemoteVideoView(userID, 'clear');\n            }\n          });\n        });\n      }\n    });\n    loading.current = false;\n  }, [loading]);\n  const sendPush = useCallback(async users => {\n    var payload = JSON.stringify({\n      message: \"Incoming Call\",\n      ios_voip: \"1\",\n      VOIPCall: \"1\"\n    });\n    var pushParameters = {\n      notification_type: \"push\",\n      user: {\n        ids: users\n      },\n      // recipients.\n      environment: \"development\",\n      // environment, can be 'production'.\n      message: QB.pushnotifications.base64Encode(payload)\n    };\n    console.log(\"============= Push Notification Payload\", pushParameters);\n    QB.pushnotifications.events.create(pushParameters, function (error, result) {\n      if (error) {\n        console.log(\"============= Push Notification Error\", error);\n      } else {\n        // success\n        console.log(\"============= Push Notification is sent.\");\n      }\n    });\n  });\n  const listenCalls = useCallback(async () => {\n    loading.current = true;\n    let mediaParams = {\n      audio: true,\n      video: true,\n      options: {\n        muted: true,\n        mirror: true\n      },\n      elemId: \"localVideo\"\n    };\n    window.addEventListener('onCallListener', QB.webrtc.onCallListener = function (session, extension) {\n      console.log('session:::', session);\n\n      if (session.state !== QB.webrtc.SessionConnectionState.CLOSED) {\n        console.log('Receiving a call');\n      }\n\n      setReceivingCall(session); // if you are going to take a call\n\n      session.getUserMedia(mediaParams, function (error, stream) {\n        if (error) {\n          console.log(error);\n        } else {\n          //run accept function here\n          console.log(stream); // session.attachMediaStream(\"mainVideo\", session.peerConnections[userId].remoteStream);\n        }\n      });\n    });\n    loading.current = false;\n  }, [loading]);\n  const acceptCall = useCallback(async session => {\n    loading.current = true;\n    console.log(session);\n    let extension = {};\n    session.accept(extension);\n    loading.current = false;\n  }, [loading]);\n  const endCall = useCallback(async session => {\n    loading.current = true;\n    console.log(session);\n    let extension = {};\n    session.stop(extension);\n    loading.current = false;\n  }, [loading]);\n  const acceptListener = useCallback(async () => {\n    loading.current = true;\n    window.addEventListener('onAcceptListener', QB.webrtc.onAcceptCallListener = function (session, userId, extension) {\n      // Call was accepted\n      console.log('session:::', session.peerConnections[userId]);\n      console.log('extension', extension);\n    });\n    loading.current = false;\n  }, [loading]);\n  const rejectListener = useCallback(async callback => {\n    loading.current = true;\n    window.addEventListener('onRejectListener', QB.webrtc.onRejectCallListener = function (session, userId, extension) {\n      // Call was accepted\n      if (callback) {\n        callback();\n      }\n\n      console.log('session:::', session.peerConnections[userId]);\n      console.log('extension', extension);\n    });\n    loading.current = false;\n  }, [loading]);\n  const remoteListener = useCallback(async () => {\n    loading.current = true;\n    window.addEventListener('onRemoteListener', QB.webrtc.onRemoteStreamListener = function (session, userID, remoteStream) {\n      // Get the other person's media\n      session.attachMediaStream(\"mainVideo\", remoteStream);\n    });\n    loading.current = false;\n  }, [loading]);\n  const stopCallListener = useCallback(async callback => {\n    loading.current = true;\n    window.addEventListener('onStopCallListener', QB.webrtc.onStopCallListener = function (session, userId, extension) {\n      console.log('onStopCallListener');\n\n      if (callback) {\n        callback();\n      }\n    });\n    loading.current = false;\n  }, [loading]);\n  const userNotAnswerListener = useCallback(async callback => {\n    loading.current = true;\n    window.addEventListener('onUserNotAnswerListener', QB.webrtc.onUserNotAnswerListener = async function (session, userId) {\n      console.log(\"======== onUserNotAnswerListener\");\n      setNoAnswer(true);\n      callback();\n    });\n    loading.current = false;\n  }, [loading]);\n  const sessionConnectionStateChangedListener = useCallback(async () => {\n    loading.current = true;\n    window.addEventListener('onSessionConnectionStateChangedListener', QB.webrtc.onSessionConnectionStateChangedListener = function (session, userId, connectionState) {\n      console.log('onSessionConnectionStateChangedListener:::', connectionState);\n      setCallStatus(connectionState); // QB.webrtc.SessionConnectionState.CONNECTING\n      // QB.webrtc.SessionConnectionState.CONNECTED\n      // QB.webrtc.SessionConnectionState.CLOSED\n      // QB.webrtc.SessionConnectionState.FAILED\n      // QB.webrtc.SessionConnectionState.COMPLETED\n    });\n    loading.current = false;\n  }, [loading]);\n  const callStatsReport = useCallback(async () => {\n    loading.current = true;\n    window.addEventListener('onCallStatsReport', QB.webrtc.onCallStatsReport = function (session, userId, stats, error) {\n      console.log('onCallStatsReport:::', stats);\n    });\n    loading.current = false;\n  }, [loading]);\n  return {\n    initQuickBlox,\n    createUserSession,\n    getRepresentativesUsers,\n    connectChatServer,\n    makeVideoCall,\n    listenCalls,\n    receivingCall,\n    acceptCall,\n    endCall,\n    acceptListener,\n    remoteListener,\n    stopCallListener,\n    userNotAnswerListener,\n    sessionConnectionStateChangedListener,\n    callStatsReport,\n    rejectListener,\n    callStatus,\n    mySession,\n    noAnswer\n  };\n};\n\n_s(useQuickBlox, \"Ao5r9d/py9/ZHKPByVZipM0t7ec=\");\n\nexport default useQuickBlox;","map":{"version":3,"sources":["/Users/andresgonzalez/Desktop/B2B-main-website/src/hooks/useQuickBlox.js"],"names":["useCallback","useRef","useState","config","QB","QBconfig","CONFIG","debug","webrtc","answerTimeInterval","dialingTimeInterval","autoReject","incomingLimit","useQuickBlox","loading","mySession","setMySession","callStatus","setCallStatus","receivingCall","setReceivingCall","noAnswer","setNoAnswer","currentUser","setCurrentUser","initQuickBlox","current","response","init","appId","authKey","authSecret","accountKey","console","log","createUserSession","email","fullName","branch","externalId","params","login","password","full_name","tag_list","user","Promise","resolve","reject","createSession","csErr","csRes","loginErr","loginUser","users","create","createErr","createUser","reloginErr","reloginUser","update","id","updateError","updateUser","getRepresentativesUsers","representatives","all","map","searchParams","get","error","result","connectChatServer","userCredentials","jid","chat","helpers","getUserJid","connect","contactList","localStorage","setItem","makeVideoCall","representativesFromQB","callType","calleesIds","sessionType","mediaParams","CallType","VIDEO","audio","video","options","muted","mirror","elemId","AUDIO","additionalOptions","session","createNewSession","getUserMedia","stream","extension","call","sendPush","forEach","userID","i","arr","peerState","connectionStateForUser","PeerConnectionState","CLOSED","payload","JSON","stringify","message","ios_voip","VOIPCall","pushParameters","notification_type","ids","environment","pushnotifications","base64Encode","events","listenCalls","window","addEventListener","onCallListener","state","SessionConnectionState","acceptCall","accept","endCall","stop","acceptListener","onAcceptCallListener","userId","peerConnections","rejectListener","callback","onRejectCallListener","remoteListener","onRemoteStreamListener","remoteStream","attachMediaStream","stopCallListener","onStopCallListener","userNotAnswerListener","onUserNotAnswerListener","sessionConnectionStateChangedListener","onSessionConnectionStateChangedListener","connectionState","callStatsReport","onCallStatsReport","stats"],"mappings":"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","sourcesContent":["import { useCallback, useRef, useState } from 'react';\nimport config from '../QBconfig'\nimport QB from 'quickblox/quickblox.min';\nimport QBconfig from \"../QBconfig\";\nconst CONFIG = {\n    debug: true,\n    webrtc: {\n        answerTimeInterval: 45,\n        dialingTimeInterval: 5,\n        autoReject: true,\n        incomingLimit: 1,\n    }\n};\n\nconst useQuickBlox = () => {\n    const loading = useRef(false);\n    const [mySession, setMySession] = useState();\n    const [callStatus, setCallStatus] = useState();\n    const [receivingCall, setReceivingCall] = useState(false);\n    const [noAnswer, setNoAnswer] = useState(false);\n    const [currentUser, setCurrentUser] = useState(false);\n\n    const initQuickBlox = useCallback(\n        async () => {\n            loading.current = true;\n            const response = await QB.init(config.appId, config.authKey, config.authSecret, config.accountKey, CONFIG);\n            console.log(response);\n            loading.current = false;\n        },\n        [loading]\n    );\n\n    const createUserSession = useCallback(\n        async (email, fullName, branch, externalId) => {\n            loading.current = true;\n            let params = {\n                login: email,\n                password: \"OneDoorCompany\",\n                full_name: fullName,\n                tag_list: branch || null,\n                externalId: externalId\n            };\n\n            const user = await new Promise(function (resolve, reject) {\n                QB.createSession(function (csErr, csRes) {\n                    if (csErr) {\n                        reject(csErr);\n                    } else {\n                        /** In first trying to login */\n                        QB.login(params, function (loginErr, loginUser) {\n                            if (loginErr) {\n                                /** Login failed, trying to create account */\n                                QB.users.create({\n                                    'login': params.login,\n                                    'password': params.password,\n                                    'full_name': params.full_name,\n                                    'email': params.login\n                                    // 'custom_data': params.tag_list\n                                }, function (createErr, createUser) {\n                                    if (createErr) {\n                                        console.log('[create user] Error:', createErr);\n                                        reject(createErr);\n                                    } else {\n                                        QB.login(params, function (reloginErr, reloginUser) {\n                                            if (reloginErr) {\n                                                console.log('[relogin user] Error:', reloginErr);\n                                            } else {\n                                                resolve(reloginUser);\n                                            }\n                                        });\n                                    }\n                                });\n                            } else {\n                                /** Update info */\n                                if (loginUser.full_name !== params.full_name) {\n                                    QB.users.update(loginUser.id, {\n                                        'full_name': params.full_name,\n                                        // 'custom_data': params.tag_list\n                                    }, function (updateError, updateUser) {\n                                        if (updateError) {\n                                            console.log('APP [update user] Error:', updateError);\n                                            reject(updateError);\n                                        } else {\n                                            resolve(updateUser);\n                                        }\n                                    });\n                                } else {\n                                    resolve(loginUser);\n                                }\n                            }\n                        });\n                    }\n                });\n            });\n            loading.current = false;\n            setCurrentUser(user)\n            return user;\n        },\n        [loading]\n    );\n\n    const getRepresentativesUsers = useCallback(\n        async (users) => {\n            loading.current = true;\n\n            let representatives = [];\n            representatives = await Promise.all(\n                users.map(async (user) => {\n                    let searchParams = { email: user.email };\n                    debugger\n                    return new Promise(function (resolve, reject) {\n                        QB.users.get(searchParams, function (error, result) {\n                            debugger\n                            if (result) {\n                                resolve(result);\n                            }\n                        });\n                    });\n                })\n            );\n\n            loading.current = false;\n            return representatives;\n        },\n        [loading]\n    );\n\n    const connectChatServer = useCallback(\n        async (user) => {\n            loading.current = true;\n            let userCredentials = {\n                jid: QB.chat.helpers.getUserJid(user?.id, QBconfig.appId),\n                password: \"OneDoorCompany\"\n            };\n            QB.chat.connect(userCredentials, function (error, contactList) {\n                if (error) {\n                    console.log('ERROR:::', error);\n                } else {\n                    localStorage.setItem('isAuth', true)\n                }\n            });\n            loading.current = false;\n        },\n        [loading]\n    );\n\n    const makeVideoCall = useCallback(\n        async (representativesFromQB, callType) => {\n            loading.current = true;\n            let calleesIds = [representativesFromQB.id]; // Users' ids, for testing purposes we use just one [0]\n            // let calleesIds = [129779412]; // Users' ids, for testing purposes we use just one [0]\n            let sessionType;\n            let mediaParams;\n            if (callType === 'VIDEO') {\n                sessionType = QB.webrtc.CallType.VIDEO;\n                mediaParams = {\n                    audio: true,\n                    video: true,\n                    options: {\n                        muted: true,\n                        mirror: true,\n                    },\n                    elemId: \"localVideo\"\n                };\n            } else {\n                sessionType = QB.webrtc.CallType.AUDIO;\n                mediaParams = {\n                    audio: true,\n                    video: false,\n                    options: {\n                        muted: true,\n                        mirror: true,\n                    },\n                    elemId: \"localVideo\",\n                };\n            }\n            let additionalOptions = {};\n\n            let session = QB.webrtc.createNewSession(calleesIds, sessionType, null, additionalOptions);\n            setMySession(session);\n\n            session.getUserMedia(mediaParams, function (error, stream) {\n                if (error) {\n                    console.log(error);\n                } else {\n                    //run call function here\n                    let extension = {\n                        \"name\": currentUser.full_name,\n                        \"email\": currentUser.email\n                    };\n                    session.call(extension, function (error) {\n                        sendPush(calleesIds)\n                        calleesIds.forEach(async function (userID, i, arr) {\n\n                            let peerState = session.connectionStateForUser(userID);\n                            console.log('peerState', peerState);\n\n\n                            if (peerState === QB.webrtc.PeerConnectionState.CLOSED) {\n                                console.log('======= CONNECTION CLOSED')\n                                // Turn off\n                                //app.helpers.toggleRemoteVideoView(userID, 'clear');\n                            }\n                        });\n                    });\n                }\n            });\n\n            loading.current = false;\n        },\n        [loading]\n    );\n\n    const sendPush = useCallback(\n        async (users) => {\n            var payload = JSON.stringify({\n                message: \"Incoming Call\",\n                ios_voip: \"1\",\n                VOIPCall: \"1\"\n            });\n            var pushParameters = {\n                notification_type: \"push\",\n                user: { ids: users }, // recipients.\n                environment: \"development\", // environment, can be 'production'.\n                message: QB.pushnotifications.base64Encode(payload)\n            };\n            console.log(\"============= Push Notification Payload\", pushParameters);\n            QB.pushnotifications.events.create(pushParameters, function (error, result) {\n                if (error) {\n                    console.log(\"============= Push Notification Error\", error);\n                } else {\n                    // success\n                    console.log(\"============= Push Notification is sent.\");\n                }\n            });\n        }\n    )\n\n    const listenCalls = useCallback(\n        async () => {\n            loading.current = true;\n            let mediaParams = {\n                audio: true,\n                video: true,\n                options: {\n                    muted: true,\n                    mirror: true,\n                },\n                elemId: \"localVideo\",\n            };\n            window.addEventListener('onCallListener', QB.webrtc.onCallListener = function (session, extension) {\n                console.log('session:::', session);\n                if (session.state !== QB.webrtc.SessionConnectionState.CLOSED) {\n                    console.log('Receiving a call');\n                }\n                setReceivingCall(session);\n\n                // if you are going to take a call\n                session.getUserMedia(mediaParams, function (error, stream) {\n                    if (error) {\n                        console.log(error)\n                    } else {\n                        //run accept function here\n                        console.log(stream);\n                        // session.attachMediaStream(\"mainVideo\", session.peerConnections[userId].remoteStream);\n                    }\n                });\n\n            })\n\n            loading.current = false;\n        },\n        [loading]\n    );\n\n    const acceptCall = useCallback(\n        async (session) => {\n            loading.current = true;\n            console.log(session);\n            let extension = {};\n            session.accept(extension);\n\n            loading.current = false;\n        },\n        [loading]\n    );\n\n    const endCall = useCallback(\n        async (session) => {\n            loading.current = true;\n            console.log(session);\n            let extension = {};\n            session.stop(extension);\n\n            loading.current = false;\n        },\n        [loading]\n    );\n\n    const acceptListener = useCallback(\n        async () => {\n            loading.current = true;\n            window.addEventListener('onAcceptListener', QB.webrtc.onAcceptCallListener = function (session, userId, extension) {\n                // Call was accepted\n                console.log('session:::', session.peerConnections[userId]);\n                console.log('extension', extension);\n            });\n\n            loading.current = false;\n        },\n        [loading]\n    );\n\n    const rejectListener = useCallback(\n        async (callback) => {\n            loading.current = true;\n            window.addEventListener('onRejectListener', QB.webrtc.onRejectCallListener = function (session, userId, extension) {\n                // Call was accepted\n                if (callback) {\n                    callback()\n                }\n                console.log('session:::', session.peerConnections[userId]);\n                console.log('extension', extension);\n            });\n\n            loading.current = false;\n        },\n        [loading]\n    );\n\n    const remoteListener = useCallback(\n        async () => {\n            loading.current = true;\n            window.addEventListener('onRemoteListener', QB.webrtc.onRemoteStreamListener = function (session, userID, remoteStream) {\n                // Get the other person's media\n                session.attachMediaStream(\"mainVideo\", remoteStream);\n            });\n            loading.current = false;\n        },\n        [loading]\n    );\n\n    const stopCallListener = useCallback(\n        async (callback) => {\n            loading.current = true;\n            window.addEventListener('onStopCallListener', QB.webrtc.onStopCallListener = function (session, userId, extension) {\n                console.log('onStopCallListener');\n                if (callback) {\n                    callback()\n                }\n            });\n            loading.current = false;\n        },\n        [loading]\n    );\n\n    const userNotAnswerListener = useCallback(\n        async (callback) => {\n            loading.current = true;\n            window.addEventListener('onUserNotAnswerListener', QB.webrtc.onUserNotAnswerListener = async function (session, userId) {\n                console.log(\"======== onUserNotAnswerListener\")\n                setNoAnswer(true);\n                callback()\n            });\n            loading.current = false;\n        },\n        [loading]\n    );\n\n    const sessionConnectionStateChangedListener = useCallback(\n        async () => {\n            loading.current = true;\n            window.addEventListener('onSessionConnectionStateChangedListener', QB.webrtc.onSessionConnectionStateChangedListener = function (session, userId, connectionState) {\n                console.log('onSessionConnectionStateChangedListener:::', connectionState);\n                setCallStatus(connectionState);\n                // QB.webrtc.SessionConnectionState.CONNECTING\n                // QB.webrtc.SessionConnectionState.CONNECTED\n                // QB.webrtc.SessionConnectionState.CLOSED\n                // QB.webrtc.SessionConnectionState.FAILED\n                // QB.webrtc.SessionConnectionState.COMPLETED\n\n            });\n            loading.current = false;\n        },\n        [loading]\n    );\n\n    const callStatsReport = useCallback(\n        async () => {\n            loading.current = true;\n            window.addEventListener('onCallStatsReport', QB.webrtc.onCallStatsReport = function (session, userId, stats, error) {\n                console.log('onCallStatsReport:::', stats);\n\n            });\n            loading.current = false;\n        },\n        [loading]\n    );\n\n\n    return {\n        initQuickBlox,\n        createUserSession,\n        getRepresentativesUsers,\n        connectChatServer,\n        makeVideoCall,\n        listenCalls,\n        receivingCall,\n        acceptCall,\n        endCall,\n        acceptListener,\n        remoteListener,\n        stopCallListener,\n        userNotAnswerListener,\n        sessionConnectionStateChangedListener,\n        callStatsReport,\n        rejectListener,\n        callStatus,\n        mySession,\n        noAnswer\n    };\n};\n\nexport default useQuickBlox;\n"]},"metadata":{},"sourceType":"module"}